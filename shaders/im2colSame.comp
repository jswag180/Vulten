#version 450
#extension GL_ARB_separate_shader_objects : enable

//layout(local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) buffer a { readonly float inData[]; };
layout(set = 0, binding = 1) buffer b {
    readonly int batches;
    readonly int hight, width, channels;
    readonly int filterH, filterW, filterIn, filterOut;
    readonly int strideH, strideW;
    readonly int dilationH, dilationW;
    readonly int resHight, resWidth;
    readonly int padTop, padBottom, padLeft, padRight;
};
//could pad the outData with 0s so that it evely fits into vec4 for that simd power
layout(set = 0, binding = 2) buffer c { writeonly float outData[]; };


int unFlatToFlat(in int x, in int y, in int width, in int channels){
    return (x * width + y) * channels;
}

int unFlatToFlat(in int x, in int y, in int width){
    return (x * width + y);
}

shared int filterArea;
shared int resChannels;

// x:batch y:row z:col
void main(){
    //int filterArea = filterH * filterW;
    //int resChannels = channels >= filterOut ? filterOut : channels;
    if(gl_LocalInvocationID.x == 0){
        filterArea = filterH * filterW;
        if(filterIn > 1){
            resChannels = channels;// >= filterOut ? filterOut : channels;
        }else{
            resChannels = channels >= filterOut ? filterOut : channels;
        }
        
        //resChannels = filterIn;
    }
    memoryBarrierShared();
    barrier();

    int inBatchOffset = int(gl_GlobalInvocationID.x) * (hight * width * channels);
    int row = int(gl_GlobalInvocationID.y);
    int col = int(gl_GlobalInvocationID.z);
    
    int outBatchOffset = int(gl_GlobalInvocationID.x) * (resHight * resWidth * (filterArea * resChannels));

    int index = unFlatToFlat(row, col, resWidth, channels);

    int paddingRowAmmount = max((row * strideH) + filterH - hight, 0);
    int paddingColAmmount = max((col * strideW) + filterW - width, 0);

    for(int fChannel = 0; fChannel < resChannels; fChannel++){
        for(int fRow = 0; fRow < filterH; fRow++){
            for(int fCol = 0; fCol < filterW; fCol++){
                // if((paddingRowAmmount > 0 && fRow == filterH - paddingRowAmmount) || (paddingColAmmount > 0 && fCol == filterW - paddingColAmmount)){
                //     outData[outBatchOffset + (index * filterArea) + (unFlatToFlat(fRow, fCol, filterW) + (filterArea * fChannel))] = 0.0;
                // }else{
                //     outData[outBatchOffset + (index * filterArea) + (unFlatToFlat(fRow, fCol, filterW) + (filterArea * fChannel))] = inData[inBatchOffset + unFlatToFlat((row * strideH) + fRow, (col * strideW) + fCol, width, channels) + fChannel];
                // }

                int x = (row * strideH) + fRow;
                int y = (col * strideW) + fCol;
                int asd = padTop + padBottom + padLeft + padRight > 0 ? 1 : 0;
                if(x < padTop || x - padTop > hight - asd ||  y < padLeft || y - padLeft > width - asd){
                    outData[outBatchOffset + (index * filterArea) + (unFlatToFlat(fRow, fCol, filterW) + (filterArea * fChannel))] = 0.0;
                }else{
                    outData[outBatchOffset + (index * filterArea) + (unFlatToFlat(fRow, fCol, filterW) + (filterArea * fChannel))] = inData[inBatchOffset + unFlatToFlat(x - padTop, y - padLeft, width, channels) + fChannel];
                }
            }
        }
    }

}